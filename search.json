[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "statslab",
    "section": "",
    "text": "Introduction\nContent covering statistics, data analysis, and computer programming. Sections are listed on the left."
  },
  {
    "objectID": "rlang.html#r-the-language",
    "href": "rlang.html#r-the-language",
    "title": "1  R & RStudio",
    "section": "1.1 R: The Language",
    "text": "1.1 R: The Language\nReleased in 1993, R is an opensource successor to S, a commercially available statistical programming language developed at Bell Labs in the 1970s. The history is not particularly relevant. However, understanding that R was originally developed with the explicit goal of teaching introductory statistics (a bit like Matlab) may help to understand some of the design choices made by the developers of R.\nThere are several attributes that make R useful for teaching statistics:\n\nR is interpreted\nR is weakly typed\nR’s the focus on data analysis is built into its native data types\nR has strong graphical abilities\n\nDon’t worry if all of these benefits are meaningless to you at this point. We’ll get into the details soon enough. The short version is that the first two bullet points are features that make programmers’ lives easier/more convenient and last two mean that R is ready-made to do data analysis.\nThere are also a variety of downsides to R, but we will try to sidestep these as much as we can. One way we will do this is by exclusively using packages from the tidyverse. Once you are familiar with one way of working in R, you can explore the many, many alternatives."
  },
  {
    "objectID": "rlang.html#rstudio",
    "href": "rlang.html#rstudio",
    "title": "1  R & RStudio",
    "section": "1.2 RStudio",
    "text": "1.2 RStudio\nThe interface between a programmer (or data analyst) and a programming language is often an integrate development environment (IDE), which is just a fancy term for a piece of software that collects a bunch of inter-related tools often useful when programming. We will be using RStudio as our IDE. As the name suggests, RStudio was designed as an R-first IDE, making things easy for those new to R and/or programming.\nFirst time users often confuse R and RStudio. At its simplest, R is like a car’s engine while RStudio is like a car’s dashboard as illustrated in Figure @ref(fig:R-vs-RStudio-1).\n\n\n\nAnalogy of difference between R and RStudio.\n\n\nMore precisely, R is the programming language that performs computations, whereas RStudio is how users interact with R."
  },
  {
    "objectID": "rlang.html#installation",
    "href": "rlang.html#installation",
    "title": "1  R & RStudio",
    "section": "1.3 Installation",
    "text": "1.3 Installation\nInstallation involves two major steps. The first step is to install R itself. You can get the most recent version from CRAN (the comprehensive R archive network): https://cloud.r-project.org. There are ready-made installers available for Linux, macOS, and Windows.\nThe second step is to install RStudio. You can download it from Posit: https://posit.co/download/rstudio-desktop/. Again, there are versions available for all major platforms."
  },
  {
    "objectID": "rlang.html#using-r-via-rstudio",
    "href": "rlang.html#using-r-via-rstudio",
    "title": "1  R & RStudio",
    "section": "1.4 Using R via RStudio",
    "text": "1.4 Using R via RStudio\nRecall our car analogy from earlier. Much as we don’t drive a car by interacting directly with the engine but rather by interacting with elements on the car’s dashboard, we won’t be using R directly but rather we will use RStudio’s interface. After you install R and RStudio on your computer, you’ll have two new programs or applications you can open. We’ll always work in RStudio and not in the R application. Figure @ref(fig:R-vs-RStudio-2) shows what icon you should be clicking on your computer.\n\n\n\nIcons of R versus RStudio on your computer.\n\n\nAfter you open RStudio, you should see something similar to Figure Figure 1.1. (Note that slight differences might exist if the RStudio interface is updated after 2019 to not be this by default.)\n\n\n\nFigure 1.1: RStudio interface to R.\n\n\nNote the three panes dividing the screen: the console pane, the files pane, and the environment pane. The console pane is where you enter R commands and R returns the corresponding results (and/or error messages if you make a mistake). We’ll dig into the other panes a bit more later."
  },
  {
    "objectID": "rlang.html#other-packages",
    "href": "rlang.html#other-packages",
    "title": "1  R & RStudio",
    "section": "1.5 Other Packages",
    "text": "1.5 Other Packages\nOne of the main strengths of R (arguably the most important strength) is the availability of many, many packages (or libraries) that extend the functionality of R in all sort of different ways. These libraries are written by a worldwide community of R users and can be downloaded for free. We will rely on a variety of these packages, so we take a moment now to discuss how packages work in R and RStudio.\nA good analogy for R packages is they are like apps you can download onto your mobile phone. So R is like a new mobile phone: while it has a certain amount of features when you use it for the first time, it doesn’t have everything. R packages are like the apps you can download onto your phone from Apple’s App Store or Android’s Google Play.\nLet’s continue this analogy by considering the Instagram app for editing and sharing pictures. Say you have purchased a new phone and you would like to share a photo you have just taken with friends on Instagram. You need to:\n\nInstall the app: Since your phone is new and does not include the Instagram app, you need to download the app from either the App Store or Google Play. You do this once and you’re set for the time being. You might need to do this again in the future when there is an update to the app.\nOpen the app: After you’ve installed Instagram, you need to open it.\n\nOnce Instagram is open on your phone, you can then proceed to share your photo with your friends and family. The process is very similar for using an R package. You need to:\n\nInstall the package: This is like installing an app on your phone. Most packages are not installed by default when you install R and RStudio. Thus, if you want to use a package, you need to install it first. Once you’ve installed a package, you likely won’t install it again unless you want to update it to a newer version.\n“Load” the package: “Loading” a package is like opening an app on your phone. Packages are not “loaded” by default when you start RStudio on your computer; you need to “load” each package you want to use every time you start RStudio.\n\nLet’s take a look at how these two steps come together to install and load the ggplot2 package for data visualization.\n\n1.5.1 Package Installation {sec-packageinstallation}\nThere are two ways to install an R package: an easy way and a more advanced way. Let’s install the ggplot2 package the easy way first as shown in Figure @ref(fig-easy-way-install). In the Files pane of RStudio:\n\nClick on the “Packages” tab.\nClick on “Install” next to Update.\nType the name of the package under “Packages (separate multiple with space or comma):” In this case, type ggplot2.\nClick “Install.”\n\n{fig-easy-way-install}\nAn alternative but slightly less convenient way to install a package is by typing install.packages(\"ggplot2\") in the console pane of RStudio and pressing Return/Enter on your keyboard. Note you must include the quotation marks around the name of the package.\nMuch like an app on your phone, you only have to install a package once. However, if you want to update a previously installed package to a newer version, you need to reinstall it by repeating the earlier steps.\n\n\n1.5.2 Package Loading\nRecall that after you’ve installed a package, you need to “load it.” In other words, you need to “open it.” We do this by using the library() command. \nFor example, to load the ggplot2 package, run the following code in the console pane. What do we mean by “run the following code”? Either type or copy-and-paste the following code into the console pane and then hit the Enter key.\n\nlibrary(ggplot2)\n\nIf after running the earlier code, a blinking cursor returns next to the &gt; “prompt” sign, it means you were successful and the ggplot2 package is now loaded and ready to use. If, however, you get a red “error message” that reads ... \nError in library(ggplot2) : there is no package called ‘ggplot2’\n... it means that you didn’t successfully install it. If you get this error message, go back to Subsection @ref(package-installation) on R package installation and make sure to install the ggplot2 package before proceeding.\n\n\n1.5.3 Package Use\nOne very common mistake new R users make when wanting to use particular packages is they forget to “load” them first by using the library() command we just saw. Remember: you have to load each package you want to use every time you start RStudio. If you don’t first “load” a package, but attempt to use one of its features, you’ll see an error message similar to:\nError: could not find function\nThis is a different error message than the one you just saw on a package not having been installed yet. R is telling you that you are trying to use a function in a package that has not yet been “loaded.” R doesn’t know where to find the function you are using. Almost all new users forget to do this when starting out, and it is a little annoying to get used to doing it. However, you’ll remember with practice and after some time it will become second nature for you."
  },
  {
    "objectID": "programming.html#commands-at-the-console",
    "href": "programming.html#commands-at-the-console",
    "title": "2  R as a Calculator",
    "section": "2.1 Commands at the console",
    "text": "2.1 Commands at the console\nOne of the easiest things you can do with R is use it as a simple calculator, so it’s a good place to start. For instance, try typing 10 + 20, and hitting enter. The simple act of typing it rather than “just reading” makes a big difference. It makes the concepts more concrete, and it ties the abstract ideas (programming and statistics) to the actual context in which you need to use them. Statistics is something you do, not just something you read about in a textbook.] When you do this, you’ve entered a command, and R will “execute” that command. What you see on screen now will be this:\n\n&gt; 10 + 20\n[1] 30\n\nNot a lot of surprises in this extract. But there’s a few things worth talking about, even with such a simple example. Firstly, it’s important that you understand how to read the extract. In this example, what I typed was the 10 + 20 part. I didn’t type the &gt; symbol: that’s just the R command prompt and isn’t part of the actual command. And neither did I type the [1] 30 part. That’s what R printed out in response to my command.\nSecondly, it’s important to understand how the output is formatted. Obviously, the correct answer to the sum 10 + 20 is 30, and not surprisingly R has printed that out as part of its response. But it’s also printed out this [1] part, which probably doesn’t make a lot of sense to you right now. You’re going to see that a lot. I’ll talk about what this means in a bit more detail later on, but for now you can think of [1] 30 as if R were saying “the answer to the 1st question you asked is 30”. That’s not quite the truth, but it’s close enough for now. And in any case it’s not really very interesting at the moment: we only asked R to calculate one thing, so obviously there’s only one answer printed on the screen. Later on this will change, and the [1] part will start to make a bit more sense. For now, I just don’t want you to get confused or concerned by it.\n\n2.1.1 An important digression about formatting\nNow that I’ve taught you these rules I’m going to change them pretty much immediately. That is because I want you to be able to copy code from the book directly into R if if you want to test things or conduct your own analyses. However, if you copy this kind of code (that shows the command prompt and the results) directly into R you will get an error\n\n&gt; 10 + 20\n[1] 30\n\nError: &lt;text&gt;:1:1: unexpected '&gt;'\n1: &gt;\n    ^\n\n\nSo instead, I’m going to provide code in a slightly different format so that it looks like this…\n\n10 + 20\n\n[1] 30\n\n\nThere are two main differences.\n\nIn your console, you type after the &gt;, but from now I I won’t show the command prompt in the book.\n\nIn the book, output is commented out with ##, in your console it appears directly after your code.\n\nThese two differences mean that if you’re working with an electronic version of the book, you can easily copy code out of the book and into the console.\nSo for example if you copied the two lines of code from the book you’d get this\n\n10 + 20\n\n[1] 30\n\n## [1] 30\n\n\n\n2.1.2 Be very careful to avoid typos\nBefore we go on to talk about other types of calculations that we can do with R, there’s a few other things I want to point out. The first thing is that, while R is good software, it’s still software. It’s pretty stupid, and because it’s stupid it can’t handle typos. It takes it on faith that you meant to type exactly what you did type. For example, suppose that you forgot to hit the shift key when trying to type +, and as a result your command ended up being 10 = 20 rather than 10 + 20. Here’s what happens:\n\n10 = 20\n\nError in 10 = 20: invalid (do_set) left-hand side to assignment\n\n\nWhat’s happened here is that R has attempted to interpret 10 = 20 as a command, and spits out an error message because the command doesn’t make any sense to it. When a human looks at this, and then looks down at his or her keyboard and sees that + and = are on the same key, it’s pretty obvious that the command was a typo. But R doesn’t know this, so it gets upset. And, if you look at it from its perspective, this makes sense. All that R “knows” is that 10 is a legitimate number, 20 is a legitimate number, and = is a legitimate part of the language too. In other words, from its perspective this really does look like the user meant to type 10 = 20, since all the individual parts of that statement are legitimate and it’s too stupid to realise that this is probably a typo. Therefore, R takes it on faith that this is exactly what you meant… it only “discovers” that the command is nonsense when it tries to follow your instructions, typo and all. And then it whinges, and spits out an error.\nEven more subtle is the fact that some typos won’t produce errors at all, because they happen to correspond to “well-formed” R commands. For instance, suppose that not only did I forget to hit the shift key when trying to type 10 + 20, I also managed to press the key next to one I meant do. The resulting typo would produce the command 10 - 20. Clearly, R has no way of knowing that you meant to add 20 to 10, not subtract 20 from 10, so what happens this time is this:\n\n10 - 20\n\n[1] -10\n\n\nIn this case, R produces the right answer, but to the the wrong question.\nTo some extent, I’m stating the obvious here, but it’s important. The people who wrote R are smart. You, the user, are smart. But R itself is dumb. And because it’s dumb, it has to be mindlessly obedient. It does exactly what you ask it to do. There is no equivalent to “autocorrect” in R, and for good reason. When doing advanced stuff – and even the simplest of statistics is pretty advanced in a lot of ways – it’s dangerous to let a mindless automaton like R try to overrule the human user. But because of this, it’s your responsibility to be careful. Always make sure you type exactly what you mean. When dealing with computers, it’s not enough to type “approximately” the right thing. In general, you absolutely must be precise in what you say to R … like all machines it is too stupid to be anything other than absurdly literal in its interpretation.\n\n\n2.1.3 R is (a bit) flexible with spacing\nOf course, now that I’ve been so uptight about the importance of always being precise, I should point out that there are some exceptions. Or, more accurately, there are some situations in which R does show a bit more flexibility than my previous description suggests. The first thing R is smart enough to do is ignore redundant spacing. What I mean by this is that, when I typed 10 + 20 before, I could equally have done this\n\n10    + 20\n\n[1] 30\n\n\nor this\n\n10+20\n\n[1] 30"
  },
  {
    "objectID": "programming.html#simple-calculations",
    "href": "programming.html#simple-calculations",
    "title": "2  R as a Calculator",
    "section": "2.2 Simple calculations",
    "text": "2.2 Simple calculations\nOkay, now that we’ve discussed some of the tedious details associated with typing R commands, let’s get back to learning how to use the most powerful piece of statistical software in the world as a $2 calculator. So far, all we know how to do is addition. Clearly, a calculator that only did addition would be a bit stupid, so I should tell you about how to perform other simple calculations using R. But first, some more terminology. Addition is an example of an “operation” that you can perform (specifically, an arithmetic operation), and the operator that performs it is +. To people with a programming or mathematics background, this terminology probably feels pretty natural, but to other people it might feel like I’m trying to make something very simple (addition) sound more complicated than it is (by calling it an arithmetic operation). To some extent, that’s true: if addition was the only operation that we were interested in, it’d be a bit silly to introduce all this extra terminology. However, as we go along, we’ll start using more and more different kinds of operations, so it’s probably a good idea to get the language straight now, while we’re still talking about very familiar concepts like addition!\n\n2.2.1 Adding, subtracting, multiplying and dividing\nSo, now that we have the terminology, let’s learn how to perform some arithmetic operations in R. To that end, Table @ref(tab:arithmetic1) lists the operators that correspond to the basic arithmetic we learned in primary school: addition, subtraction, multiplication and division.\n\n\n\nBasic arithmetic operations in R. These five operators are used very frequently throughout the text, so it’s important to be familiar with them at the outset.\n\n\noperation\noperator\nexample input\nexample output\n\n\n\n\naddition\n+\n10 + 2\n12\n\n\nsubtraction\n-\n9 - 3\n6\n\n\nmultiplication\n*\n5 * 5\n25\n\n\ndivision\n/\n10 / 3\n3\n\n\npower\n^\n5 ^ 2\n25\n\n\n\n\n\nAs you can see, R uses fairly standard symbols to denote each of the different operations you might want to perform: addition is done using the + operator, subtraction is performed by the - operator, and so on. So if I wanted to find out what 57 times 61 is (and who wouldn’t?), I can use R instead of a calculator, like so:\n\n57 * 61\n\n[1] 3477\n\n\nSo that’s handy.\n\n\n2.2.2 Taking powers\nThe first four operations listed in Table @ref(tab:arithmetic1) are things we all learned in primary school, but they aren’t the only arithmetic operations built into R. There are three other arithmetic operations that I should probably mention: taking powers, doing integer division, and calculating a modulus. Of the three, the only one that is of any real importance for the purposes of this book is taking powers, so I’ll discuss that one here: the other two are discussed in Chapter @ref(datahandling).\nFor those of you who can still remember your high school maths, this should be familiar. But for some people high school maths was a long time ago, and others of us didn’t listen very hard in high school. It’s not complicated. As I’m sure everyone will probably remember the moment they read this, the act of multiplying a number \\(x\\) by itself \\(n\\) times is called “raising \\(x\\) to the \\(n\\)-th power”. Mathematically, this is written as \\(x^n\\). Some values of \\(n\\) have special names: in particular \\(x^2\\) is called \\(x\\)-squared, and \\(x^3\\) is called \\(x\\)-cubed. So, the 4th power of 5 is calculated like this: \\[\n5^4 = 5 \\times 5 \\times 5 \\times 5\n\\]\nOne way that we could calculate \\(5^4\\) in R would be to type in the complete multiplication as it is shown in the equation above. That is, we could do this\n\n5 * 5 * 5 * 5\n\n[1] 625\n\n\nbut it does seem a bit tedious. It would be very annoying indeed if you wanted to calculate \\(5^{15}\\), since the command would end up being quite long. Therefore, to make our lives easier, we use the power operator instead. When we do that, our command to calculate \\(5^4\\) goes like this:\n\n5 ^ 4\n\n[1] 625\n\n\nMuch easier.\n\n\n2.2.3 Doing calculations in the right order\nOkay. At this point, you know how to take one of the most powerful pieces of statistical software in the world, and use it as a $2 calculator. And as a bonus, you’ve learned a few very basic programming concepts. That’s not nothing (you could argue that you’ve just saved yourself $2) but on the other hand, it’s not very much either. In order to use R more effectively, we need to introduce more programming concepts.\nIn most situations where you would want to use a calculator, you might want to do multiple calculations. R lets you do this, just by typing in longer commands. In fact, we’ve already seen an example of this earlier, when I typed in 5 * 5 * 5 * 5. However, let’s try a slightly different example:\n\n1 + 2 * 4\n\n[1] 9\n\n\nClearly, this isn’t a problem for R either. However, it’s worth stopping for a second, and thinking about what R just did. Clearly, since it gave us an answer of 9 it must have multiplied 2 * 4 (to get an interim answer of 8) and then added 1 to that. But, suppose it had decided to just go from left to right: if R had decided instead to add 1+2 (to get an interim answer of 3) and then multiplied by 4, it would have come up with an answer of 12.\nTo answer this, you need to know the order of operations that R uses. If you remember back to your high school maths classes, it’s actually the same order that you got taught when you were at school: the “BEDMAS” order. That is, first calculate things inside Brackets (), then calculate Exponents ^, then Division / and Multiplication *, then Addition + and Subtraction -. So, to continue the example above, if we want to force R to calculate the 1+2 part before the multiplication, all we would have to do is enclose it in brackets:\n\n(1 + 2) * 4 \n\n[1] 12\n\n\nThis is a fairly useful thing to be able to do. The only other thing I should point out about order of operations is what to expect when you have two operations that have the same priority: that is, how does R resolve ties? For instance, multiplication and division are actually the same priority, but what should we expect when we give R a problem like 4 / 2 * 3 to solve? If it evaluates the multiplication first and then the division, it would calculate a value of two-thirds. But if it evaluates the division first it calculates a value of 6. The answer, in this case, is that R goes from left to right, so in this case the division step would come first:\n\n4 / 2 * 3\n\n[1] 6\n\n\nAll of the above being said, it’s helpful to remember that brackets always come first. So, if you’re ever unsure about what order R will do things in, an easy solution is to enclose the thing you want it to do first in brackets. There’s nothing stopping you from typing (4 / 2) * 3. By enclosing the division in brackets we make it clear which thing is supposed to happen first. In this instance you wouldn’t have needed to, since R would have done the division first anyway, but when you’re first starting out it’s better to make sure R does what you want!"
  },
  {
    "objectID": "programming.html#assign",
    "href": "programming.html#assign",
    "title": "2  R as a Calculator",
    "section": "2.3 Storing a number as a variable",
    "text": "2.3 Storing a number as a variable\nOne of the most important things to be able to do in R (or any programming language, for that matter) is to store information in variables. Variables in R aren’t exactly the same thing as the variables we talked about in the last chapter on research methods, but they are similar. At a conceptual level you can think of a variable as label for a certain piece of information, or even several different pieces of information. When doing statistical analysis in R all of your data (the variables you measured in your study) will be stored as variables in R, but as well see later in the book you’ll find that you end up creating variables for other things too. However, before we delve into all the messy details of data sets and statistical analysis, let’s look at the very basics for how we create variables and work with them.\n\n2.3.1 Variable assignment using &lt;- and -&gt;\nSince we’ve been working with numbers so far, let’s start by creating variables to store our numbers. And since most people like concrete examples, let’s invent one. Suppose I’m trying to calculate how much money I’m going to make from this book. There’s several different numbers I might want to store. Firstly, I need to figure out how many copies I’ll sell. This isn’t exactly Harry Potter, so let’s assume I’m only going to sell one copy per student in my class. That’s 350 sales, so let’s create a variable called sales. What I want to do is assign a value to my variable sales, and that value should be 350. We do this by using the assignment operator, which is &lt;-. Here’s how we do it:\n\nsales &lt;- 350\n\nWhen you hit enter, R doesn’t print out any output. It just gives you another command prompt. However, behind the scenes R has created a variable called sales and given it a value of 350. You can check that this has happened by asking R to print the variable on screen. And the simplest way to do that is to type the name of the variable and hit enter.\n\nsales\n\n[1] 350\n\n\nSo that’s nice to know. Anytime you can’t remember what R has got stored in a particular variable, you can just type the name of the variable and hit enter.\nOkay, so now we know how to assign variables. Actually, there’s a bit more you should know. Firstly, one of the curious features of R is that there are several different ways of making assignments. In addition to the &lt;- operator, we can also use -&gt; and =, and it’s pretty important to understand the differences between them. Let’s start by considering -&gt;, since that’s the easy one (we’ll discuss the use of = in Section @ref(functionarguments). As you might expect from just looking at the symbol, it’s almost identical to &lt;-. It’s just that the arrow (i.e., the assignment) goes from left to right. So if I wanted to define my sales variable using -&gt;, I would write it like this:\n\n350 -&gt; sales\n\nThis has the same effect: and it still means that I’m only going to sell 350 copies. Sigh. Apart from this superficial difference, &lt;- and -&gt; are identical. In fact, as far as R is concerned, they’re actually the same operator, just in a “left form” and a “right form”.\n\n\n2.3.2 Doing calculations using variables\nOkay, let’s get back to my original story. In my quest to become rich, I’ve written this textbook. To figure out how good a strategy is, I’ve started creating some variables in R. In addition to defining a sales variable that counts the number of copies I’m going to sell, I can also create a variable called royalty, indicating how much money I get per copy. Let’s say that my royalties are about $7 per book:\n\nsales &lt;- 350\nroyalty &lt;- 7\n\nThe nice thing about variables (in fact, the whole point of having variables) is that we can do anything with a variable that we ought to be able to do with the information that it stores. That is, since R allows me to multiply 350 by 7\n\n350 * 7\n\n[1] 2450\n\n\nit also allows me to multiply sales by royalty\n\nsales * royalty\n\n[1] 2450\n\n\nAs far as R is concerned, the sales * royalty command is the same as the 350 * 7 command. Not surprisingly, I can assign the output of this calculation to a new variable, which I’ll call revenue. And when we do this, the new variable revenue gets the value 2450. So let’s do that, and then get R to print out the value of revenue so that we can verify that it’s done what we asked:\n\nrevenue &lt;- sales * royalty\nrevenue\n\n[1] 2450\n\n\nThat’s fairly straightforward. A slightly more subtle thing we can do is reassign the value of my variable, based on its current value. For instance, suppose that one of my students (no doubt under the influence of psychotropic drugs) loves the book so much that he or she donates me an extra $550. The simplest way to capture this is by a command like this:\n\nrevenue &lt;- revenue + 550\nrevenue\n\n[1] 3000\n\n\nIn this calculation, R has taken the old value of revenue (i.e., 2450) and added 550 to that value, producing a value of 3000. This new value is assigned to the revenue variable, overwriting its previous value. In any case, we now know that I’m expecting to make $3000 off this. Pretty sweet, I thinks to myself. Or at least, that’s what I thinks until I do a few more calculation and work out what the implied hourly wage I’m making off this looks like.\n\n\n2.3.3 Rules and conventions for naming variables\nIn the examples that we’ve seen so far, my variable names (sales and revenue) have just been English-language words written using lowercase letters. However, R allows a lot more flexibility when it comes to naming your variables, as the following list of rules illustrates:\n\nVariable names can only use the upper case alphabetic characters A-Z as well as the lower case characters a-z. You can also include numeric characters 0-9 in the variable name, as well as the period . or underscore _ character. In other words, you can use SaL.e_s as a variable name (though I can’t think why you would want to), but you can’t use Sales?.\nVariable names cannot include spaces: therefore my sales is not a valid name, but my.sales is.\nVariable names are case sensitive: that is, Sales and sales are different variable names.\nVariable names must start with a letter or a period. You can’t use something like _sales or 1sales as a variable name. You can use .sales as a variable name if you want, but it’s not usually a good idea. By convention, variables starting with a . are used for special purposes, so you should avoid doing so.\nVariable names cannot be one of the reserved keywords. These are special names that R needs to keep “safe” from us mere users, so you can’t use them as the names of variables. The keywords are: if, else, repeat, while, function, for, in, next, break, TRUE, FALSE, NULL, Inf, NaN, NA, NA_integer_, NA_real_, NA_complex_, and finally, NA_character_. Don’t feel especially obliged to memorise these: if you make a mistake and try to use one of the keywords as a variable name, R will complain about it like the whiny little automaton it is.\n\nIn addition to those rules that R enforces, there are some informal conventions that people tend to follow when naming variables. One of them you’ve already seen: i.e., don’t use variables that start with a period. But there are several others. You aren’t obliged to follow these conventions, and there are many situations in which it’s advisable to ignore them, but it’s generally a good idea to follow them when you can:\n\nUse informative variable names. As a general rule, using meaningful names like sales and revenue is preferred over arbitrary ones like variable1 and variable2. Otherwise it’s very hard to remember what the contents of different variables are, and it becomes hard to understand what your commands actually do.\nUse short variable names. Typing is a pain and no-one likes doing it. So we much prefer to use a name like sales over a name like sales.for.this.book.that.you.are.reading. Obviously there’s a bit of a tension between using informative names (which tend to be long) and using short names (which tend to be meaningless), so use a bit of common sense when trading off these two conventions.\nUse one of the conventional naming styles for multi-word variable names. Suppose I want to name a variable that stores “my new salary”. Obviously I can’t include spaces in the variable name, so how should I do this? There are three different conventions that you sometimes see R users employing. Firstly, you can separate the words using periods, which would give you my.new.salary as the variable name. Alternatively, you could separate words using underscores, as in my_new_salary. Finally, you could use capital letters at the beginning of each word (except the first one), which gives you myNewSalary as the variable name. I don’t think there’s any strong reason to prefer one over the other, but it’s important to be consistent."
  },
  {
    "objectID": "programming.html#functions",
    "href": "programming.html#functions",
    "title": "2  R as a Calculator",
    "section": "2.4 Functions",
    "text": "2.4 Functions\nThe symbols +, -, * and so on are examples of operators. As we’ve seen, you can do quite a lot of calculations just by using these operators. However, in order to do more advanced calculations (and later on, to do actual statistics), you’re going to need to start using functions. I’ll talk in more detail about functions and how they work in Section @ref(functions), but for now let’s just dive in and use a few. To get started, suppose I wanted to take the square root of 225. The square root, in case your high school maths is a bit rusty, is just the opposite of squaring a number. So, for instance, since “5 squared is 25” I can say that “5 is the square root of 25”. The usual notation for this is\n\\[\n\\sqrt{25} = 5\n\\]\nthough sometimes you’ll also see it written like this \\(25^{0.5} = 5.\\) This second way of writing it is kind of useful to “remind” you of the mathematical fact that “square root of \\(x\\)” is actually the same as “raising \\(x\\) to the power of 0.5”. Personally, I’ve never found this to be terribly meaningful psychologically, though I have to admit it’s quite convenient mathematically. Anyway, it’s not important. What is important is that you remember what a square root is, since we’re going to need it later on.\nTo calculate the square root of 25, I can do it in my head pretty easily, since I memorised my multiplication tables when I was a kid. It gets harder when the numbers get bigger, and pretty much impossible if they’re not whole numbers. This is where something like R comes in very handy. Let’s say I wanted to calculate \\(\\sqrt{225}\\), the square root of 225. There’s two ways I could do this using R. Firstly, since the square root of 255 is the same thing as raising 225 to the power of 0.5, I could use the power operator ^, just like we did earlier:\n\n225 ^ 0.5\n\n[1] 15\n\n\nHowever, there’s a second way that we can do this, since R also provides a square root function, sqrt(). To calculate the square root of 255 using this function, what I do is insert the number 225 in the parentheses. That is, the command I type is this:\n\nsqrt( 225 )\n\n[1] 15\n\n\nand as you might expect from our previous discussion, the spaces in between the parentheses are purely cosmetic. I could have typed sqrt(225) or sqrt( 225   ) and gotten the same result. When we use a function to do something, we generally refer to this as calling the function, and the values that we type into the function (there can be more than one) are referred to as the arguments of that function.\nObviously, the sqrt() function doesn’t really give us any new functionality, since we already knew how to do square root calculations by using the power operator ^, though I do think it looks nicer when we use sqrt(). However, there are lots of other functions in R: in fact, almost everything of interest that I’ll talk about in this book is an R function of some kind. For example, one function that we will need to use in this book is the absolute value function. Compared to the square root function, it’s extremely simple: it just converts negative numbers to positive numbers, and leaves positive numbers alone. Mathematically, the absolute value of \\(x\\) is written \\(|x|\\) or sometimes \\(\\mbox{abs}(x)\\). Calculating absolute values in R is pretty easy, since R provides the abs() function that you can use for this purpose. When you feed it a positive number…\n\nabs( 21 )\n\n[1] 21\n\n\nthe absolute value function does nothing to it at all. But when you feed it a negative number, it spits out the positive version of the same number, like this:\n\nabs( -13 )\n\n[1] 13\n\n\nIn all honesty, there’s nothing that the absolute value function does that you couldn’t do just by looking at the number and erasing the minus sign if there is one. However, there’s a few places later in the book where we have to use absolute values, so I thought it might be a good idea to explain the meaning of the term early on.\nBefore moving on, it’s worth noting that – in the same way that R allows us to put multiple operations together into a longer command, like 1 + 2*4 for instance – it also lets us put functions together and even combine functions with operators if we so desire. For example, the following is a perfectly legitimate command:\n\nsqrt( 1 + abs(-8) )\n\n[1] 3\n\n\nWhen R executes this command, starts out by calculating the value of abs(-8), which produces an intermediate value of 8. Having done so, the command simplifies to sqrt( 1 + 8 ). To solve the square root it first needs to add 1 + 8 to get 9, at which point it evaluates sqrt(9), and so it finally outputs a value of 3.\n\n2.4.1 Function arguments, their names and their defaults\nThere’s two more fairly important things that you need to understand about how functions work in R, and that’s the use of “named” arguments, and default values” for arguments. Not surprisingly, that’s not to say that this is the last we’ll hear about how functions work, but they are the last things we desperately need to discuss in order to get you started. To understand what these two concepts are all about, I’ll introduce another function. The round() function can be used to round some value to the nearest whole number. For example, I could type this:\n\nround( 3.1415 )\n\n[1] 3\n\n\nPretty straightforward, really. However, suppose I only wanted to round it to two decimal places: that is, I want to get 3.14 as the output. The round() function supports this, by allowing you to input a second argument to the function that specifies the number of decimal places that you want to round the number to. In other words, I could do this:\n\nround( 3.14165, 2 )\n\n[1] 3.14\n\n\nWhat’s happening here is that I’ve specified two arguments: the first argument is the number that needs to be rounded (i.e., 3.1415), the second argument is the number of decimal places that it should be rounded to (i.e., 2), and the two arguments are separated by a comma. In this simple example, it’s quite easy to remember which one argument comes first and which one comes second, but for more complicated functions this is not easy. Fortunately, most R functions make use of argument names. For the round() function, for example the number that needs to be rounded is specified using the x argument, and the number of decimal points that you want it rounded to is specified using the digits argument. Because we have these names available to us, we can specify the arguments to the function by name. We do so like this:\n\nround( x = 3.1415, digits = 2 )\n\n[1] 3.14\n\n\nNotice that this is kind of similar in spirit to variable assignment (Section @ref(assign)), except that I used = here, rather than &lt;-. In both cases we’re specifying specific values to be associated with a label. However, there are some differences between what I was doing earlier on when creating variables, and what I’m doing here when specifying arguments, and so as a consequence it’s important that you use = in this context.\nAs you can see, specifying the arguments by name involves a lot more typing, but it’s also a lot easier to read. Because of this, the commands in this book will usually specify arguments by name, since that makes it clearer to you what I’m doing. However, one important thing to note is that when specifying the arguments using their names, it doesn’t matter what order you type them in. But if you don’t use the argument names, then you have to input the arguments in the correct order. In other words, these three commands all produce the same output…\n\nround( 3.14165, 2 )\n\n[1] 3.14\n\nround( x = 3.1415, digits = 2 )\n\n[1] 3.14\n\nround( digits = 2, x = 3.1415 )\n\n[1] 3.14\n\n\nbut this one does not…\n\nround( 2, 3.14165 )\n\n[1] 2\n\n\nHow do you find out what the correct order is? There’s a few different ways, but the easiest one is to look at the help documentation for the function (see Section @ref(help). However, if you’re ever unsure, it’s probably best to actually type in the argument name.\nOkay, so that’s the first thing I said you’d need to know: argument names. The second thing you need to know about is default values. Notice that the first time I called the round() function I didn’t actually specify the digits argument at all, and yet R somehow knew that this meant it should round to the nearest whole number. How did that happen? The answer is that the digits argument has a default value of 0, meaning that if you decide not to specify a value for digits then R will act as if you had typed digits = 0. This is quite handy: the vast majority of the time when you want to round a number you want to round it to the nearest whole number, and it would be pretty annoying to have to specify the digits argument every single time. On the other hand, sometimes you actually do want to round to something other than the nearest whole number, and it would be even more annoying if R didn’t allow this! Thus, by having digits = 0 as the default value, we get the best of both worlds."
  },
  {
    "objectID": "programming.html#vectors",
    "href": "programming.html#vectors",
    "title": "2  R as a Calculator",
    "section": "2.5 Storing many numbers as a vector",
    "text": "2.5 Storing many numbers as a vector\nAt this point we’ve covered functions in enough detail to get us safely through the next couple of chapters (with one small exception: see Section @ref(generics), so let’s return to our discussion of variables. When I introduced variables in Section @ref(assign) I showed you how we can use variables to store a single number. In this section, we’ll extend this idea and look at how to store multiple numbers within the one variable. In R, the name for a variable that can store multiple values is a vector. So let’s create one.\n\n2.5.1 Creating a vector\nLet’s stick to my silly “get rich quick by textbook writing” example. Suppose the textbook company (if I actually had one, that is) sends me sales data on a monthly basis. Since my class start in late February, we might expect most of the sales to occur towards the start of the year. Let’s suppose that I have 100 sales in February, 200 sales in March and 50 sales in April, and no other sales for the rest of the year. What I would like to do is have a variable – let’s call it sales.by.month – that stores all this sales data. The first number stored should be 0 since I had no sales in January, the second should be 100, and so on. The simplest way to do this in R is to use the combine function, c(). To do so, all we have to do is type all the numbers you want to store in a comma separated list, like this:\n\nsales.by.month &lt;- c(0, 100, 200, 50, 0, 0, 0, 0, 0, 0, 0, 0)\nsales.by.month\n\n [1]   0 100 200  50   0   0   0   0   0   0   0   0\n\n\nTo use the correct terminology here, we have a single variable here called sales.by.month: this variable is a vector that consists of 12 elements.\n\n\n2.5.2 A handy digression\nNow that we’ve learned how to put information into a vector, the next thing to understand is how to pull that information back out again. However, before I do so it’s worth taking a slight detour. If you’ve been following along, typing all the commands into R yourself, it’s possible that the output that you saw when we printed out the sales.by.month vector was slightly different to what I showed above. This would have happened if the window (or the RStudio panel) that contains the R console is really, really narrow. If that were the case, you might have seen output that looks something like this:\n\nsales.by.month\n\n [1]   0 100 200  50\n [5]   0   0   0   0\n [9]   0   0   0   0\n\n\nBecause there wasn’t much room on the screen, R has printed out the results over three lines. But that’s not the important thing to notice. The important point is that the first line has a [1] in front of it, whereas the second line starts with [5] and the third with [9]. It’s pretty clear what’s happening here. For the first row, R has printed out the 1st element through to the 4th element, so it starts that row with a [1]. For the second row, R has printed out the 5th element of the vector through to the 8th one, and so it begins that row with a [5] so that you can tell where it’s up to at a glance. It might seem a bit odd to you that R does this, but in some ways it’s a kindness, especially when dealing with larger data sets!\n\n\n2.5.3 Getting information out of vectors\nTo get back to the main story, let’s consider the problem of how to get information out of a vector. At this point, you might have a sneaking suspicion that the answer has something to do with the [1] and [9] things that R has been printing out. And of course you are correct. Suppose I want to pull out the February sales data only. February is the second month of the year, so let’s try this:\n\nsales.by.month[2]\n\n[1] 100\n\n\nYep, that’s the February sales all right. But there’s a subtle detail to be aware of here: notice that R outputs [1] 100, not [2] 100. This is because R is being extremely literal. When we typed in sales.by.month[2], we asked R to find exactly one thing, and that one thing happens to be the second element of our sales.by.month vector. So, when it outputs [1] 100 what R is saying is that the first number that we just asked for is 100. This behaviour makes more sense when you realise that we can use this trick to create new variables. For example, I could create a february.sales variable like this:\n\nfebruary.sales &lt;- sales.by.month[2]\nfebruary.sales\n\n[1] 100\n\n\nObviously, the new variable february.sales should only have one element and so when I print it out this new variable, the R output begins with a [1] because 100 is the value of the first (and only) element of february.sales. The fact that this also happens to be the value of the second element of sales.by.month is irrelevant. We’ll pick this topic up again shortly (Section @ref(indexing)).\n\n\n2.5.4 Altering the elements of a vector\nSometimes you’ll want to change the values stored in a vector. Imagine my surprise when the publisher rings me up to tell me that the sales data for May are wrong. There were actually an additional 25 books sold in May, but there was an error or something so they hadn’t told me about it. How can I fix my sales.by.month variable? One possibility would be to assign the whole vector again from the beginning, using c(). But that’s a lot of typing. Also, it’s a little wasteful: why should R have to redefine the sales figures for all 12 months, when only the 5th one is wrong? Fortunately, we can tell R to change only the 5th element, using this trick:\n\nsales.by.month[5] &lt;- 25\nsales.by.month\n\n [1]   0 100 200  50  25   0   0   0   0   0   0   0\n\n\nAnother way to edit variables is to use the edit() or fix() functions. I won’t discuss them in detail right now, but you can check them out on your own.\n\n\n2.5.5 Useful things to know about vectors\nBefore moving on, I want to mention a couple of other things about vectors. Firstly, you often find yourself wanting to know how many elements there are in a vector (usually because you’ve forgotten). You can use the length() function to do this. It’s quite straightforward:\n\nlength( x = sales.by.month )\n\n[1] 12\n\n\nSecondly, you often want to alter all of the elements of a vector at once. For instance, suppose I wanted to figure out how much money I made in each month. Since I’m earning an exciting $7 per book (no seriously, that’s actually pretty close to what authors get on the very expensive textbooks that you’re expected to purchase), what I want to do is multiply each element in the sales.by.month vector by 7. R makes this pretty easy, as the following example shows:\n\nsales.by.month * 7\n\n [1]    0  700 1400  350  175    0    0    0    0    0    0    0\n\n\nIn other words, when you multiply a vector by a single number, all elements in the vector get multiplied. The same is true for addition, subtraction, division and taking powers. So that’s neat. On the other hand, suppose I wanted to know how much money I was making per day, rather than per month. Since not every month has the same number of days, I need to do something slightly different. Firstly, I’ll create two new vectors:\n\ndays.per.month &lt;- c(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)\nprofit &lt;- sales.by.month * 7\n\nObviously, the profit variable is the same one we created earlier, and the days.per.month variable is pretty straightforward. What I want to do is divide every element of profit by the corresponding element of days.per.month. Again, R makes this pretty easy:\n\nprofit / days.per.month\n\n [1]  0.000000 25.000000 45.161290 11.666667  5.645161  0.000000  0.000000\n [8]  0.000000  0.000000  0.000000  0.000000  0.000000\n\n\nI still don’t like all those zeros, but that’s not what matters here. Notice that the second element of the output is 25, because R has divided the second element of profit (i.e. 700) by the second element of days.per.month (i.e. 28). Similarly, the third element of the output is equal to 1400 divided by 31, and so on. We’ll talk more about calculations involving vectors later on (and in particular a thing called the “recycling rule”; Section @ref(recycling)), but that’s enough detail for now."
  },
  {
    "objectID": "programming.html#text",
    "href": "programming.html#text",
    "title": "2  R as a Calculator",
    "section": "2.6 Storing text data",
    "text": "2.6 Storing text data\nA lot of the time your data will be numeric in nature, but not always. Sometimes your data really needs to be described using text, not using numbers. To address this, we need to consider the situation where our variables store text. To create a variable that stores the word “hello”, we can type this:\n\ngreeting &lt;- \"hello\"\ngreeting\n\n[1] \"hello\"\n\n\nWhen interpreting this, it’s important to recognise that the quote marks here aren’t part of the string itself. They’re just something that we use to make sure that R knows to treat the characters that they enclose as a piece of text data, known as a character string. In other words, R treats \"hello\" as a string containing the word “hello”; but if I had typed hello instead, R would go looking for a variable by that name! You can also use 'hello' to specify a character string.\nOkay, so that’s how we store the text. Next, it’s important to recognise that when we do this, R stores the entire word \"hello\" as a single element: our greeting variable is not a vector of five different letters. Rather, it has only the one element, and that element corresponds to the entire character string \"hello\". To illustrate this, if I actually ask R to find the first element of greeting, it prints the whole string:\n\ngreeting[1]\n\n[1] \"hello\"\n\n\nOf course, there’s no reason why I can’t create a vector of character strings. For instance, if we were to continue with the example of my attempts to look at the monthly sales data for my book, one variable I might want would include the names of all 12 months. To do so, I could type in a command like this\n\nmonths &lt;- c(\"January\", \"February\", \"March\", \"April\", \"May\", \"June\",\n            \"July\", \"August\", \"September\", \"October\", \"November\", \n            \"December\")\n\nThis is a character vector containing 12 elements, each of which is the name of a month. So if I wanted R to tell me the name of the fourth month, all I would do is this:\n\nmonths[4]\n\n[1] \"April\"\n\n\n\n2.6.1 Working with text\nWorking with text data is somewhat more complicated than working with numeric data, and I discuss some of the basic ideas in Section @ref(textprocessing), but for purposes of the current chapter we only need this bare bones sketch. The only other thing I want to do before moving on is show you an example of a function that can be applied to text data. So far, most of the functions that we have seen (i.e., sqrt(), abs() and round()) only make sense when applied to numeric data (e.g., you can’t calculate the square root of “hello”), and we’ve seen one function that can be applied to pretty much any variable or vector (i.e., length()). So it might be nice to see an example of a function that can be applied to text.\nThe function I’m going to introduce you to is called nchar(), and what it does is count the number of individual characters that make up a string. Recall earlier that when we tried to calculate the length() of our greeting variable it returned a value of 1: the greeting variable contains only the one string, which happens to be \"hello\". But what if I want to know how many letters there are in the word? Sure, I could count them, but that’s boring, and more to the point it’s a terrible strategy if what I wanted to know was the number of letters in War and Peace. That’s where the nchar() function is helpful:\n\nnchar( x = greeting )\n\n[1] 5\n\n\nThat makes sense, since there are in fact 5 letters in the string \"hello\". Better yet, you can apply nchar() to whole vectors. So, for instance, if I want R to tell me how many letters there are in the names of each of the 12 months, I can do this:\n\nnchar( x = months )\n\n [1] 7 8 5 5 3 4 4 6 9 7 8 8\n\n\nSo that’s nice to know. The nchar() function can do a bit more than this, and there’s a lot of other functions that you can do to extract more information from text or do all sorts of fancy things. However, the goal here is not to teach any of that! The goal right now is just to see an example of a function that actually does work when applied to text."
  },
  {
    "objectID": "programming.html#logicals",
    "href": "programming.html#logicals",
    "title": "2  R as a Calculator",
    "section": "2.7 Storing “true or false” data",
    "text": "2.7 Storing “true or false” data\nTime to move onto a third kind of data. A key concept in that a lot of R relies on is the idea of a logical value. A logical value is an assertion about whether something is true or false. This is implemented in R in a pretty straightforward way. There are two logical values, namely TRUE and FALSE. Despite the simplicity, a logical values are very useful things. Let’s see how they work.\n\n2.7.1 Assessing mathematical truths\nIn George Orwell’s classic book 1984, one of the slogans used by the totalitarian Party was “two plus two equals five”, the idea being that the political domination of human freedom becomes complete when it is possible to subvert even the most basic of truths. It’s a terrifying thought, especially when the protagonist Winston Smith finally breaks down under torture and agrees to the proposition. “Man is infinitely malleable”, the book says. I’m pretty sure that this isn’t true of humans but it’s definitely not true of R. R is not infinitely malleable. It has rather firm opinions on the topic of what is and isn’t true, at least as regards basic mathematics. If I ask it to calculate 2 + 2, it always gives the same answer, and it’s not bloody 5:\n\n2 + 2\n\n[1] 4\n\n\nOf course, so far R is just doing the calculations. I haven’t asked it to explicitly assert that \\(2+2 = 4\\) is a true statement. If I want R to make an explicit judgement, I can use a command like this:\n\n2 + 2 == 4\n\n[1] TRUE\n\n\nWhat I’ve done here is use the equality operator, ==, to force R to make a “true or false” judgement. Okay, let’s see what R thinks of the Party slogan:\n\n2+2 == 5\n\n[1] FALSE\n\n\nBooyah! Freedom and ponies for all! Or something like that. Anyway, it’s worth having a look at what happens if I try to force R to believe that two plus two is five by making an assignment statement like 2 + 2 = 5 or 2 + 2 &lt;- 5. When I do this, here’s what happens:\n\n2 + 2 = 5\n\nError in 2 + 2 = 5: target of assignment expands to non-language object\n\n\nR doesn’t like this very much. It recognises that 2 + 2 is not a variable (that’s what the “non-language object” part is saying), and it won’t let you try to “reassign” it. While R is pretty flexible, and actually does let you do some quite remarkable things to redefine parts of R itself, there are just some basic, primitive truths that it refuses to give up. It won’t change the laws of addition, and it won’t change the definition of the number 2.\nThat’s probably for the best.\n\n\n2.7.2 Logical operations\nSo now we’ve seen logical operations at work, but so far we’ve only seen the simplest possible example. You probably won’t be surprised to discover that we can combine logical operations with other operations and functions in a more complicated way, like this:\n\n3*3 + 4*4 == 5*5\n\n[1] TRUE\n\n\nor this\n\nsqrt( 25 ) == 5\n\n[1] TRUE\n\n\nNot only that, but as Table @ref(tab:logicals) illustrates, there are several other logical operators that you can use, corresponding to some basic mathematical concepts.\n\n\n\nSome logical operators. Technically I should be calling these “binary relational operators”, but quite frankly I don’t want to. It’s my book so no-one can make me.\n\n\noperation\noperator\nexample input\nanswer\n\n\n\n\nless than\n&lt;\n2 &lt; 3\nTRUE\n\n\nless than or equal to\n&lt;=\n2 &lt;= 2\nTRUE\n\n\ngreater than\n&gt;\n2 &gt; 3\nFALSE\n\n\ngreater than or equal to\n&gt;=\n2 &gt;= 2\nTRUE\n\n\nequal to\n==\n2 == 3\nFALSE\n\n\nnot equal to\n!=\n2 != 3\nTRUE\n\n\n\n\n\nHopefully these are all pretty self-explanatory: for example, the less than operator &lt; checks to see if the number on the left is less than the number on the right. If it’s less, then R returns an answer of TRUE:\n\n99 &lt; 100\n\n[1] TRUE\n\n\nbut if the two numbers are equal, or if the one on the right is larger, then R returns an answer of FALSE, as the following two examples illustrate:\n\n100 &lt; 100\n\n[1] FALSE\n\n100 &lt; 99\n\n[1] FALSE\n\n\nIn contrast, the less than or equal to operator &lt;= will do exactly what it says. It returns a value of TRUE if the number of the left hand side is less than or equal to the number on the right hand side. So if we repeat the previous two examples using &lt;=, here’s what we get:\n\n100 &lt;= 100\n\n[1] TRUE\n\n100 &lt;= 99\n\n[1] FALSE\n\n\nAnd at this point I hope it’s pretty obvious what the greater than operator &gt; and the greater than or equal to operator &gt;= do! Next on the list of logical operators is the not equal to operator != which – as with all the others – does what it says it does. It returns a value of TRUE when things on either side are not identical to each other. Therefore, since \\(2+2\\) isn’t equal to \\(5\\), we get:\n\n2 + 2 != 5\n\n[1] TRUE\n\n\nWe’re not quite done yet. There are three more logical operations that are worth knowing about, listed in Table @ref(tab:logicals2).\n\n\n\nSome more logical operators.\n\n\noperation\noperator\nexample input\nanswer\n\n\n\n\nnot\n!\n!(1==1)\nFALSE\n\n\nor\n|\n(1==1) | (2==3)\nTRUE\n\n\nand\n&\n(1==1) & (2==3)\nFALSE\n\n\n\n\n\nThese are the not operator !, the and operator &, and the or operator |. Like the other logical operators, their behaviour is more or less exactly what you’d expect given their names. For instance, if I ask you to assess the claim that “either \\(2+2 = 4\\) or \\(2+2 = 5\\)” you’d say that it’s true. Since it’s an “either-or” statement, all we need is for one of the two parts to be true. That’s what the | operator does:\n\n(2+2 == 4) | (2+2 == 5)\n\n[1] TRUE\n\n\nOn the other hand, if I ask you to assess the claim that “both \\(2+2 = 4\\) and \\(2+2 = 5\\)” you’d say that it’s false. Since this is an and statement we need both parts to be true. And that’s what the & operator does:\n\n(2+2 == 4) & (2+2 == 5)\n\n[1] FALSE\n\n\nFinally, there’s the not operator, which is simple but annoying to describe in English. If I ask you to assess my claim that “it is not true that \\(2+2 = 5\\)” then you would say that my claim is true; because my claim is that “\\(2+2 = 5\\) is false”. And I’m right. If we write this as an R command we get this:\n\n! (2+2 == 5)\n\n[1] TRUE\n\n\nIn other words, since 2+2 == 5 is a FALSE statement, it must be the case that !(2+2 == 5) is a TRUE one. Essentially, what we’ve really done is claim that “not false” is the same thing as “true”. Obviously, this isn’t really quite right in real life. But R lives in a much more black or white world: for R everything is either true or false. No shades of gray are allowed. We can actually see this much more explicitly, like this:\n\n! FALSE\n\n[1] TRUE\n\n\nOf course, in our \\(2+2 = 5\\) example, we didn’t really need to use “not” ! and “equals to” == as two separate operators. We could have just used the “not equals to” operator != like this:\n\n2+2 != 5\n\n[1] TRUE\n\n\nBut there are many situations where you really do need to use the ! operator. We’ll see some later on.\n\n\n2.7.3 Storing and using logical data\nUp to this point, I’ve introduced numeric data (in Sections @ref(assign) and @ref(vectors)) and character data (in Section @ref(text)). So you might not be surprised to discover that these TRUE and FALSE values that R has been producing are actually a third kind of data, called logical data. That is, when I asked R if 2 + 2 == 5 and it said [1] FALSE in reply, it was actually producing information that we can store in variables. For instance, I could create a variable called is.the.Party.correct, which would store R’s opinion:\n\nis.the.Party.correct &lt;- 2 + 2 == 5\nis.the.Party.correct\n\n[1] FALSE\n\n\nAlternatively, you can assign the value directly, by typing TRUE or FALSE in your command. Like this:\n\nis.the.Party.correct &lt;- FALSE\nis.the.Party.correct\n\n[1] FALSE\n\n\nBetter yet, because it’s kind of tedious to type TRUE or FALSE over and over again, R provides you with a shortcut: you can use T and F instead (but it’s case sensitive: t and f won’t work).\n::: {.callout-caution} ## TRUE and FALSE\nTRUE and FALSE are reserved keywords in R, so you can trust that they always mean what they say they do. Unfortunately, the shortcut versions T and F do not have this property. It’s even possible to create variables that set up the reverse meanings, by typing commands like T &lt;- FALSE and F &lt;- TRUE. This is kind of insane, and something that is generally thought to be a design flaw in R. Anyway, the long and short of it is that it’s safer to use TRUE and FALSE.:::\nSo this works:\n\nis.the.Party.correct &lt;- F\nis.the.Party.correct\n\n[1] FALSE\n\n\nbut this doesn’t:\n\nis.the.Party.correct &lt;- f\n\nError in eval(expr, envir, enclos): object 'f' not found\n\n\n\n\n2.7.4 Vectors of logicals\nThe next thing to mention is that you can store vectors of logical values in exactly the same way that you can store vectors of numbers (Section @ref(vectors)) and vectors of text data (Section @ref(text)). Again, we can define them directly via the c() function, like this:\n\nx &lt;- c(TRUE, TRUE, FALSE)\nx\n\n[1]  TRUE  TRUE FALSE\n\n\nor you can produce a vector of logicals by applying a logical operator to a vector. This might not make a lot of sense to you, so let’s unpack it slowly. First, let’s suppose we have a vector of numbers (i.e., a “non-logical vector”). For instance, we could use the sales.by.month vector that we were using in Section @ref(vectors). Suppose I wanted R to tell me, for each month of the year, whether I actually sold a book in that month. I can do that by typing this:\n\nsales.by.month &gt; 0\n\n [1] FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\n[12] FALSE\n\n\nand again, I can store this in a vector if I want, as the example below illustrates:\n\nany.sales.this.month &lt;- sales.by.month &gt; 0\nany.sales.this.month\n\n [1] FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\n[12] FALSE\n\n\nIn other words, any.sales.this.month is a logical vector whose elements are TRUE only if the corresponding element of sales.by.month is greater than zero. For instance, since I sold zero books in January, the first element is FALSE.\n\n\n2.7.5 Applying logical operation to text\nIn a moment (Section @ref(indexing)) I’ll show you why these logical operations and logical vectors are so handy, but before I do so I want to very briefly point out that you can apply them to text as well as to logical data. It’s just that we need to be a bit more careful in understanding how R interprets the different operations. In this section I’ll talk about how the equal to operator == applies to text, since this is the most important one. Obviously, the not equal to operator != gives the exact opposite answers to == so I’m implicitly talking about that one too, but I won’t give specific commands showing the use of !=. As for the other operators, I’ll defer a more detailed discussion of this topic to Section @ref(logictext2).\nOkay, let’s see how it works. In one sense, it’s very simple. For instance, I can ask R if the word \"cat\" is the same as the word \"dog\", like this:\n\n\"cat\" == \"dog\"\n\n[1] FALSE\n\n\nThat’s pretty obvious, and it’s good to know that even R can figure that out. Similarly, R does recognise that a \"cat\" is a \"cat\":\n\n\"cat\" == \"cat\"\n\n[1] TRUE\n\n\nAgain, that’s exactly what we’d expect. However, what you need to keep in mind is that R is not at all tolerant when it comes to grammar and spacing. If two strings differ in any way whatsoever, R will say that they’re not equal to each other, as the following examples indicate:\n\n\" cat\" == \"cat\"\n\n[1] FALSE\n\n\"cat\" == \"CAT\"\n\n[1] FALSE\n\n\"cat\" == \"c a t\"\n\n[1] FALSE"
  },
  {
    "objectID": "programming.html#indexing",
    "href": "programming.html#indexing",
    "title": "2  R as a Calculator",
    "section": "2.8 Indexing vectors",
    "text": "2.8 Indexing vectors\nOne last thing to add before finishing up this chapter. So far, whenever I’ve had to get information out of a vector, all I’ve done is typed something like months[4]; and when I do this R prints out the fourth element of the months vector. In this section, I’ll show you two additional tricks for getting information out of the vector.\n\n2.8.1 Extracting multiple elements\nOne very useful thing we can do is pull out more than one element at a time. In the previous example, we only used a single number (i.e., 2) to indicate which element we wanted. Alternatively, we can use a vector. So, suppose I wanted the data for February, March and April. What I could do is use the vector c(2,3,4) to indicate which elements I want R to pull out. That is, I’d type this:\n\nsales.by.month[ c(2,3,4) ]\n\n[1] 100 200  50\n\n\nNotice that the order matters here. If I asked for the data in the reverse order (i.e., April first, then March, then February) by using the vector c(4,3,2), then R outputs the data in the reverse order:\n\nsales.by.month[ c(4,3,2) ]\n\n[1]  50 200 100\n\n\nA second thing to be aware of is that R provides you with handy shortcuts for very common situations. For instance, suppose that I wanted to extract everything from the 2nd month through to the 8th month. One way to do this is to do the same thing I did above, and use the vector c(2,3,4,5,6,7,8) to indicate the elements that I want. That works just fine\n\nsales.by.month[ c(2,3,4,5,6,7,8) ]\n\n[1] 100 200  50  25   0   0   0\n\n\nbut it’s kind of a lot of typing. To help make this easier, R lets you use 2:8 as shorthand for c(2,3,4,5,6,7,8), which makes things a lot simpler. First, let’s just check that this is true:\n\n2:8\n\n[1] 2 3 4 5 6 7 8\n\n\nNext, let’s check that we can use the 2:8 shorthand as a way to pull out the 2nd through 8th elements of sales.by.months:\n\nsales.by.month[2:8]\n\n[1] 100 200  50  25   0   0   0\n\n\nSo that’s kind of neat.\n\n\n2.8.2 Logical indexing\nAt this point, I can introduce an extremely useful tool called logical indexing. In the last section, I created a logical vector any.sales.this.month, whose elements are TRUE for any month in which I sold at least one book, and FALSE for all the others. However, that big long list of TRUEs and FALSEs is a little bit hard to read, so what I’d like to do is to have R select the names of the months for which I sold any books. Earlier on, I created a vector months that contains the names of each of the months. This is where logical indexing is handy. What I need to do is this:\n\nmonths[ sales.by.month &gt; 0 ]\n\n[1] \"February\" \"March\"    \"April\"    \"May\"     \n\n\nTo understand what’s happening here, it’s helpful to notice that sales.by.month &gt; 0 is the same logical expression that we used to create the any.sales.this.month vector in the last section. In fact, I could have just done this:\n\nmonths[ any.sales.this.month ]\n\n[1] \"February\" \"March\"    \"April\"    \"May\"     \n\n\nand gotten exactly the same result. In order to figure out which elements of months to include in the output, what R does is look to see if the corresponding element in any.sales.this.month is TRUE. Thus, since element 1 of any.sales.this.month is FALSE, R does not include \"January\" as part of the output; but since element 2 of any.sales.this.month is TRUE, R does include \"February\" in the output. Note that there’s no reason why I can’t use the same trick to find the actual sales numbers for those months. The command to do that would just be this:\n\nsales.by.month [ sales.by.month &gt; 0 ]\n\n[1] 100 200  50  25\n\n\nIn fact, we can do the same thing with text. Here’s an example. Suppose that – to continue the saga of the textbook sales – I later find out that the bookshop only had sufficient stocks for a few months of the year. They tell me that early in the year they had \"high\" stocks, which then dropped to \"low\" levels, and in fact for one month they were \"out\" of copies of the book for a while before they were able to replenish them. Thus I might have a variable called stock.levels which looks like this:\n\nstock.levels&lt;-c(\"high\", \"high\", \"low\", \"out\", \"out\", \"high\",\n                \"high\", \"high\", \"high\", \"high\", \"high\", \"high\")\n\nstock.levels\n\n [1] \"high\" \"high\" \"low\"  \"out\"  \"out\"  \"high\" \"high\" \"high\" \"high\" \"high\"\n[11] \"high\" \"high\"\n\n\nThus, if I want to know the months for which the bookshop was out of my book, I could apply the logical indexing trick, but with the character vector stock.levels, like this:\n\nmonths[stock.levels == \"out\"]\n\n[1] \"April\" \"May\"  \n\n\nAlternatively, if I want to know when the bookshop was either low on copies or out of copies, I could do this:\n\nmonths[stock.levels == \"out\" | stock.levels == \"low\"]\n\n[1] \"March\" \"April\" \"May\"  \n\n\nor this\n\nmonths[stock.levels != \"high\" ]\n\n[1] \"March\" \"April\" \"May\"  \n\n\nEither way, I get the answer I want.\nAt this point, I hope you can see why logical indexing is such a useful thing. It’s a very basic, yet very powerful way to manipulate data. We’ll talk a lot more about how to manipulate data in Chapter @ref(datahandling), since it’s a critical skill for real world research that is often overlooked in introductory research methods classes (or at least, that’s been my experience). It does take a bit of practice to become completely comfortable using logical indexing, so it’s a good idea to play around with these sorts of commands. Try creating a few different variables of your own, and then ask yourself questions like “how do I get R to spit out all the elements that are [blah]”. Practice makes perfect, and it’s only by practicing logical indexing that you’ll perfect the art of yelling frustrated insults at your computer."
  },
  {
    "objectID": "programming.html#quitting-r",
    "href": "programming.html#quitting-r",
    "title": "2  R as a Calculator",
    "section": "2.9 Quitting R",
    "text": "2.9 Quitting R\n\n\n\nThe dialog box that shows up when you try to close RStudio.\n\n\nThere’s one last thing I should cover in this chapter: how to quit R. You can just shut down the application in the normal way (e.g., File-&gt;Quit Session). However, R also has a function, q(), that you can use to quit, which can be handy. Regardless of what method you use to quit R, when you do so for the first time R will probably ask you if you want to save the “workspace image”. We’ll talk a lot more about loading and saving data in Section @ref(load), but I figured we’d better quickly cover this now otherwise you’re going to get annoyed when you close R at the end of the chapter. If you’re using RStudio, you’ll see a dialog box that looks like the one shown in Figure @ref(fig:quitR). If you’re using a text based interface you’ll see this:\n\nq()\n\n## Save workspace image? [y/n/c]: \n\nThe y/n/c part here is short for “yes / no / cancel”. Type y if you want to save, n if you don’t, and c if you’ve changed your mind and you don’t want to quit after all.\nWhat does this actually mean? What’s going on is that R wants to know if you want to save all those variables that you’ve been creating, so that you can use them later. This sounds like a great idea, so it’s really tempting to type y or click the “Save” button. To be honest though, I very rarely do this, and it kind of annoys me a little bit… what R is really asking is if you want it to store these variables in a “default” data file, which it will automatically reload for you next time you open R. And quite frankly, if I’d wanted to save the variables, then I’d have already saved them before trying to quit. Not only that, I’d have saved them to a location of my choice, so that I can find it again later. So I personally never bother with this.\nIn fact, every time I install R on a new machine one of the first things I do is change the settings so that it never asks me again. You can do this in RStudio really easily: use the menu system to find the RStudio option; the dialog box that comes up will give you an option to tell R never to whine about this again (see Figure @ref(fig:RStudiooptions). On a Mac, you can open this window by going to the “RStudio” menu and selecting “Preferences”. On a Windows machine you go to the “Tools” menu and select “Global Options”. Under the “General” tab you’ll see an option that reads “Save workspace to .Rdata on exit”. By default this is set to “ask”. If you want R to stop asking, change it to “never”."
  },
  {
    "objectID": "data.html#load",
    "href": "data.html#load",
    "title": "3  Working with Data",
    "section": "3.1 Loading and saving data",
    "text": "3.1 Loading and saving data\nThere are several different types of files that are likely to be relevant to us when doing data analysis. There are three in particular that are especially important from the perspective of this book:\n\nComma separated value (CSV) files are those with a .csv file extension. These are just regular old text files, and they can be opened with almost any software. This means that storing data in CSV files does not tie users to any particular software and keeps things simple.\nWorkspace files are those with a .Rdata file extension. This is the standard kind of file that R uses to store data and variables. They’re called “workspace files” because you can use them to save your whole workspace.\n\n\n3.1.1 Importing data from CSV files using loadingcsv\nOne quite commonly used data format is the humble “comma separated value” file, also called a CSV file, and usually bearing the file extension .csv. CSV files are just plain old-fashioned text files, and what they store is basically just a table of data. This is illustrated in Figure Figure 3.1, which shows a file called booksales.csv that I’ve created. As you can see, each row corresponds to a variable, and each row represents the book sales data for one month. The first row doesn’t contain actual data though: it has the names of the variables.\n\n\n\nFigure 3.1: The booksales.csv data file. On the left, I’ve opened the file in using a spreadsheet program (OpenOffice), which shows that the file is basically a table. On the right, the same file is open in a standard text editor (the TextEdit program on a Mac), which shows how the file is formatted. The entries in the table are wrapped in quote marks and separated by commas.\n\n\nIf RStudio were not available to you, the easiest way to open this file would be to use the read.csv() function. This function is pretty flexible, and I’ll talk a lot more about it’s capabilities in Section 3.1.2 for more details, but for now there’s only two arguments to the function that I’ll mention:\n\nfile. This should be a character string that specifies a path to the file that needs to be loaded. You can use an absolute path or a relative path to do so.\nheader. This is a logical value indicating whether or not the first row of the file contains variable names. The default value is TRUE.\n\nTherefore, to import the CSV file, the command I need is:\n\nbooks &lt;- read.csv( file = \"booksales.csv\" )\n\nThere are two very important points to notice here. Firstly, notice that I didn’t try to use the load() function, because that function is only meant to be used for .Rdata files. If you try to use load() on other types of data, you get an error. Secondly, notice that when I imported the CSV file I assigned the result to a variable, which I imaginatively called books file. There’s a reason for this. The idea behind an .Rdata file is that it stores a whole workspace. So, if you had the ability to look inside the file yourself you’d see that the data file keeps track of all the variables and their names. So when you load() the file, R restores all those original names. CSV files are treated differently: as far as R is concerned, the CSV only stores one variable, but that variable is big table. So when you import that table into the workspace, R expects you to give it a name.] Let’s have a look at what we’ve got:\n\nprint( books )\n\n       Month Days Sales Stock.Levels\n1    January   31     0         high\n2   February   28   100         high\n3      March   31   200          low\n4      April   30    50          out\n5        May   31     0          out\n6       June   30     0         high\n7       July   31     0         high\n8     August   31     0         high\n9  September   30     0         high\n10   October   31     0         high\n11  November   30     0         high\n12  December   31     0         high\n\n\nClearly, it’s worked, but the format of this output is a bit unfamiliar. We haven’t seen anything like this before. What you’re looking at is a data frame, which is a very important kind of variable in R, and one I’ll discuss in Section Chapter 5 For now, let’s just be happy that we imported the data and that it looks about right.\n\n\n\n\n\n\nNote\n\n\n\nIn a lot of books you’ll see the read.table() function used for this purpose instead of read.csv(). They’re more or less identical functions, with the same arguments and everything. They differ only in the default values.\n\n\n\n\n3.1.2 Importing data from CSV files using RStudio\nYet again, importing data is easier in RStudio. In the environment panel in RStudio you should see a button called “Import Dataset”. Click on that, and it will give you a couple of options: select the “From Text File…” option, and it will open up a very familiar dialog box asking you to select a file: if you’re on a Mac, it’ll look like the usual Finder/Explorer window that you use to choose a file. I’m assuming that you’re familiar with your own computer, so you should have no problem finding the CSV file that you want to import! Find the one you want, then click on the “Open” button. When you do this, you’ll see a window that looks like the one in Figure Figure 3.2.\n\n\n\nFigure 3.2: A dialog box on a Mac asking you to select the CSV file R should try to import. Mac users will recognise this immediately: it’s the usual way in which a Mac asks you to find a file. Windows users won’t see this: they’ll see the usual explorer window that Windows always gives you when it wants you to select a file.\n\n\nThe import data set window is relatively straightforward to understand.\n\n\n\nThe RStudio window for importing a CSV file into R.\n\n\nIn the top left corner, you need to type the name of the variable you R to create. By default, that will be the same as the file name: our file is called booksales.csv, so RStudio suggests the name booksales. If you’re happy with that, leave it alone. If not, type something else. Immediately below this are a few things that you can tweak to make sure that the data gets imported correctly:\n\nHeading. Does the first row of the file contain raw data, or does it contain headings for each variable? The booksales.csv file has a header at the top, so I selected “yes”.\nSeparator. What character is used to separate different entries? In most CSV files this will be a comma (it is “comma separated” after all). But you can change this if your file is different.\nDecimal. What character is used to specify the decimal point? In English speaking countries, this is almost always a period (i.e., .). That’s not universally true: many European countries use a comma. So you can change that if you need to.\nQuote. What character is used to denote a block of text? That’s usually going to be a double quote mark. It is for the booksales.csv file, so that’s what I selected.\n\nThe nice thing about the RStudio window is that it shows you the raw data file at the top of the window, and it shows you a preview of the data at the bottom. If the data at the bottom doesn’t look right, try changing some of the settings on the left hand side. Once you’re happy, click “Import”. When you do, two commands appear in the R console:\n\nbooksales &lt;- read.csv(\"~/Rbook/data/booksales.csv\")\nView(booksales)\n\nThe first of these commands is the one that loads the data. The second one will display a pretty table showing the data in RStudio.\n\n\n3.1.3 Loading workspace files using R\nWhen I used the list.files() command to list the contents of the /Users/dan/Rbook/data directory, the output referred to a file called booksales.Rdata. Let’s say I want to load the data from this file into my workspace. The way I do this is with the load() function. There are two arguments to this function, but the only one we’re interested in is\n\nfile. This should be a character string that specifies a path to the file that needs to be loaded. You can use an absolute path or a relative path to do so.\n\nUsing the absolute file path, the command would look like this:\n\nload( file = \"/Users/dan/Rbook/data/booksales.Rdata\" )\n\nbut this is pretty lengthy. Given that the working directory is /Users/dan/Rbook/data, I could use a relative file path, like so:\n\nload( file = \"/Users/dan/Rbook/data/booksales.Rdata\" )\n\nHowever, my preference is usually to change the working directory first, and then load the file. What that would look like is this:\n\nsetwd( \"../data\" )         # move to the data directory\nload( \"booksales.Rdata\" )  # load the data\n\nIf I were then to type who() I’d see that there are several new variables in my workspace now. Throughout this book, whenever you see me loading a file, I will assume that the file is actually stored in the working directory, or that you’ve changed the working directory so that R is pointing at the directory that contains the file. Obviously, you don’t need type that command yourself: you can use the RStudio file panel to do the work.\n\n\n3.1.4 Loading workspace files using RStudio\nOkay, so how do we open an .Rdata file using the RStudio file panel? It’s terribly simple. First, use the file panel to find the folder that contains the file you want to load. If you look at Figure Figure 3.3, you can see that there are several .Rdata files listed. Let’s say I want to load the booksales.Rdata file. All I have to do is click on the file name. RStudio brings up a little dialog box asking me to confirm that I do want to load this file. I click yes. The following command then turns up in the console,\n\nload(\"~/Rbook/data/booksales.Rdata\")\n\nand the new variables will appear in the workspace (you’ll see them in the Environment panel in RStudio, or if you type who()). So easy it barely warrants having its own section.\n\n\n\nFigure 3.3: The file panel is the area shown in the lower right hand corner. It provides a very easy way to browse and navigate your computer using R. See main text for details.\n\n\n\n\n3.1.5 Saving a workspace file using save\nNot surprisingly, saving data is very similar to loading data. Although RStudio provides a simple way to save files (see below), it’s worth understanding the actual commands involved. There are two commands you can use to do this, save() and save.image(). If you’re happy to save all of the variables in your workspace into the data file, then you should use save.image(). And if you’re happy for R to save the file into the current working directory, all you have to do is this:\n\nsave.image( file = \"myfile.Rdata\" )\n\nSince file is the first argument, you can shorten this to save.image(\"myfile.Rdata\"); and if you want to save to a different directory, then (as always) you need to be more explicit about specifying the path to the file. Suppose, however, I have several variables in my workspace, and I only want to save some of them. For instance, I might have this as my workspace:\n\nwho()\n##   -- Name --   -- Class --   -- Size --\n##   data         data.frame    3 x 2     \n##   handy        character     1         \n##   junk         numeric       1        \n\nI want to save data and handy, but not junk. But I don’t want to delete junk right now, because I want to use it for something else later on. This is where the save() function is useful, since it lets me indicate exactly which variables I want to save. Here is one way I can use the save function to solve my problem:\n\nsave(data, handy, file = \"myfile.Rdata\")\n\nImportantly, you must specify the name of the file argument. The reason is that if you don’t do so, R will think that \"myfile.Rdata\" is actually a variable that you want to save, and you’ll get an error message. Finally, I should mention a second way to specify which variables the save() function should save, which is to use the list argument. You do so like this:\n\nsave.me &lt;- c(\"data\", \"handy\")   # the variables to be saved\nsave( file = \"booksales2.Rdata\", list = save.me )   # the command to save them\n\n\n\n3.1.6 Saving a workspace file using RStudio\nRStudio allows you to save the workspace pretty easily. In the environment panel (@fig:workspace) you can see the “save” button. There’s no text, but it’s the same icon that gets used on every computer everywhere: it’s the one that looks like a floppy disk. You know, those things that haven’t been used in about 20 years.\n\n\n\nFigure 3.4: The RStudio Environment panel shows you the contents of the workspace. The view shown above is the list view. To switch to the grid view, click on the menu item on the top right that currently reads list. Select grid from the dropdown menu, and then it will switch to a view like the one shown in the other workspace figure\n\n\nAlternatively, go to the “Session” menu and click on the “Save Workspace As…” option. This will bring up the standard “save” dialog box for your operating system. Type in the name of the file that you want to save it to, and all the variables in your workspace will be saved to disk. You’ll see an R command like this:\n\nsave.image(\"~/Desktop/Untitled.RData\")\n\nPretty straightforward, really."
  },
  {
    "objectID": "tidyverse.html#tidy-data-ex",
    "href": "tidyverse.html#tidy-data-ex",
    "title": "4  The Tidyverse",
    "section": "4.1 “Tidy” data",
    "text": "4.1 “Tidy” data\nLet’s now learn about the concept of “tidy” data format.\n\n4.1.1 Definition of “tidy” data\nYou have surely heard the word “tidy” in your life:\n\n“Tidy up your room!”\n“Write your homework in a tidy way so it is easier to provide feedback.”\nMarie Kondo’s best-selling book, The Life-Changing Magic of Tidying Up: The Japanese Art of Decluttering and Organizing, and Netflix TV series Tidying Up with Marie Kondo.\n“I am not by any stretch of the imagination a tidy person, and the piles of unread books on the coffee table and by my bed have a plaintive, pleading quality to me - ‘Read me, please!’” - Linda Grant\n\nWhat does it mean for your data to be “tidy”? While “tidy” has a clear English meaning of “organized,” the word “tidy” in data science using R means that your data follows a standardized format. We will follow Hadley Wickham’s definition of “tidy” data [@tidy] shown also in Figure @ref(fig:tidyfig):\n\nA dataset is a collection of values, usually either numbers (if quantitative) or strings AKA text data (if qualitative/categorical). Values are organised in two ways. Every value belongs to a variable and an observation. A variable contains all values that measure the same underlying attribute (like height, temperature, duration) across units. An observation contains all values measured on the same unit (like a person, or a day, or a city) across attributes.\n“Tidy” data is a standard way of mapping the meaning of a dataset to its structure. A dataset is messy or tidy depending on how rows, columns and tables are matched up with observations, variables and types. In tidy data:\n\nEach variable forms a column.\nEach observation forms a row.\nEach type of observational unit forms a table.\n\n\n(ref:tidy-r4ds) Tidy data graphic from R for Data Science.\n\n\n\nTidy data\n\n\nFor example, say you have the following table of stock prices in Table @ref(tab:non-tidy-stocks):\n\n\n\nStock prices (non-tidy format)\n\n\nDate\nBoeing stock price\nAmazon stock price\nGoogle stock price\n\n\n\n\n2009-01-01\n$173.55\n$174.90\n$174.34\n\n\n2009-01-02\n$172.61\n$171.42\n$170.04\n\n\n\n\n\n\n\nAlthough the data are neatly organized in a rectangular spreadsheet-type format, they do not follow the definition of data in “tidy” format. While there are three variables corresponding to three unique pieces of information (date, stock name, and stock price), there are not three columns. In “tidy” data format, each variable should be its own column, as shown in Table @ref(tab:tidy-stocks). Notice that both tables present the same information, but in different formats.\n\n\n\nStock prices (tidy format)\n\n\nDate\nStock Name\nStock Price\n\n\n\n\n2009-01-01\nBoeing\n$173.55\n\n\n2009-01-01\nAmazon\n$174.90\n\n\n2009-01-01\nGoogle\n$174.34\n\n\n2009-01-02\nBoeing\n$172.61\n\n\n2009-01-02\nAmazon\n$171.42\n\n\n2009-01-02\nGoogle\n$170.04\n\n\n\n\n\n\n\nNow we have the requisite three columns Date, Stock Name, and Stock Price. On the other hand, consider the data in Table @ref(tab:tidy-stocks-2).\n\n\n\nExample of tidy data\n\n\nDate\nBoeing Price\nWeather\n\n\n\n\n2009-01-01\n$173.55\nSunny\n\n\n2009-01-02\n$172.61\nOvercast\n\n\n\n\n\n\n\nIn this case, even though the variable “Boeing Price” occurs just like in our non-“tidy” data in Table @tab:non-tidy-stocks, the data is “tidy” since there are three variables corresponding to three unique pieces of information: Date, Boeing price, and the Weather that particular day."
  },
  {
    "objectID": "tidyverse.html#tidyverse-package",
    "href": "tidyverse.html#tidyverse-package",
    "title": "4  The Tidyverse",
    "section": "4.2 tidyverse package",
    "text": "4.2 tidyverse package\nThe following four packages, which are among four of the most frequently used R packages for data science, will be heavily used throughout the book:\n\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(readr)\nlibrary(tidyr)\n\nThe ggplot2 package is for data visualization, dplyr is for data wrangling, readr is for importing spreadsheet data into R, and tidyr is for converting data to “tidy” format. There is a much quicker way to load these packages than by individually loading them: by installing and loading the tidyverse package. The tidyverse package acts as an “umbrella” package whereby installing/loading it will install/load multiple packages at once for you.\nAfter installing the tidyverse package as you would a normal package as seen in Section @ref(packages), running:\n\nlibrary(tidyverse)\n\nwould be the same as running:\n\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(readr)\nlibrary(tidyr)\nlibrary(purrr)\nlibrary(tibble)\nlibrary(stringr)\nlibrary(forcats)\n\nThe purrr, tibble, stringr, and forcats are left for a more advanced book; check out R for Data Science to learn about these packages.\nFor the remainder of this book, we’ll start every chapter by running library(tidyverse), instead of loading the various component packages individually. The tidyverse “umbrella” package gets its name from the fact that all the functions in all its packages are designed to have common inputs and outputs:"
  },
  {
    "objectID": "tibbles.html#what-is-a-tibble",
    "href": "tibbles.html#what-is-a-tibble",
    "title": "5  Dataframes",
    "section": "5.1 What is a tibble?",
    "text": "5.1 What is a tibble?"
  },
  {
    "objectID": "tibbles.html#converting-to-tidy-data",
    "href": "tibbles.html#converting-to-tidy-data",
    "title": "5  Dataframes",
    "section": "5.2 Converting to “tidy” data",
    "text": "5.2 Converting to “tidy” data\nFor the rest of this book, we will primarily deal with data that is already in “tidy” format as well. This is not always the case however with all datasets in the world. If your original data frame is in wide (non-“tidy”) format and you would like to use the tidyverse packages, you will first have to convert it to “tidy” format. To do so, we recommend using the pivot_longer() function in the tidyr package [@R-tidyr].\nLet’s load some data from the fivethirtyeight package. The fivethirtyeight package [@R-fivethirtyeight] provides access to the datasets used in many articles published by the data journalism website, FiveThirtyEight.com. For a complete list of all 129 datasets included in the fivethirtyeight package, check out the package webpage by going to: https://fivethirtyeight-r.netlify.app/articles/fivethirtyeight.html.\nLet’s focus our attention on the drinks data frame:\n\n\n# A tibble: 5 × 5\n  country     beer_servings spirit_servings wine_servings total_litres_of_pure…¹\n  &lt;chr&gt;               &lt;int&gt;           &lt;int&gt;         &lt;int&gt;                  &lt;dbl&gt;\n1 Afghanistan             0               0             0                    0  \n2 Albania                89             132            54                    4.9\n3 Algeria                25               0            14                    0.7\n4 Andorra               245             138           312                   12.4\n5 Angola                217              57            45                    5.9\n# … with abbreviated variable name ¹​total_litres_of_pure_alcohol\n\n\nAfter reading the help file by running (?drinks), you’ll see that drinks is a data frame containing results from a survey of beer, spirits, and wine consumption originally reported on FiveThirtyEight.com in Mona Chalabi’s article: “Dear Mona Followup: Where Do People Drink The Most Beer, Wine And Spirits?”.\nLet’s narrow down the data a bit. We’ll only consider 4 countries (the United States, China, Italy, and Saudi Arabia), omit the total_litres_of_pure_alcohol variable, and rename the other variables to something a bit more convenient. Don’t worry about the code here. We’ll get into all of these operations more in the chapter on Chapter 6.\n\ndrinks_smaller &lt;- drinks %&gt;% \n  filter(country %in% c(\"USA\", \"China\", \"Italy\", \"Saudi Arabia\")) %&gt;% \n  select(-total_litres_of_pure_alcohol) %&gt;% \n  rename(beer = beer_servings, spirit = spirit_servings, wine = wine_servings)\ndrinks_smaller\n\n# A tibble: 4 × 4\n  country       beer spirit  wine\n  &lt;chr&gt;        &lt;int&gt;  &lt;int&gt; &lt;int&gt;\n1 China           79    192     8\n2 Italy           85     42   237\n3 Saudi Arabia     0      5     0\n4 USA            249    158    84\n\n\nNote that this data is not in “tidy” format. However, we can convert it to tidy format by using the pivot_longer() function from the tidyr package as follows:\n\ndrinks_smaller_tidy &lt;- drinks_smaller %&gt;% \n  pivot_longer(names_to = \"type\", \n               values_to = \"servings\", \n               cols = -country)\ndrinks_smaller_tidy\n\n# A tibble: 12 × 3\n   country      type   servings\n   &lt;chr&gt;        &lt;chr&gt;     &lt;int&gt;\n 1 China        beer         79\n 2 China        spirit      192\n 3 China        wine          8\n 4 Italy        beer         85\n 5 Italy        spirit       42\n 6 Italy        wine        237\n 7 Saudi Arabia beer          0\n 8 Saudi Arabia spirit        5\n 9 Saudi Arabia wine          0\n10 USA          beer        249\n11 USA          spirit      158\n12 USA          wine         84\n\n\nWe set the arguments to pivot_longer() as follows:\n\nnames_to here corresponds to the name of the variable in the new “tidy”/long data frame that will contain the column names of the original data. Observe how we set names_to = \"type\". In the resulting drinks_smaller_tidy, the column type contains the three types of alcohol beer, spirit, and wine. Since type is a variable name that doesn’t appear in drinks_smaller, we use quotation marks around it. You’ll receive an error if you just use names_to = type here.\nvalues_to here is the name of the variable in the new “tidy” data frame that will contain the values of the original data. Observe how we set values_to = \"servings\" since each of the numeric values in each of the beer, wine, and spirit columns of the drinks_smaller data corresponds to a value of servings. In the resulting drinks_smaller_tidy, the column servings contains the 4 \\(\\times\\) 3 = 12 numerical values. Note again that servings doesn’t appear as a variable in drinks_smaller so it again needs quotation marks around it for the values_to argument.\nThe third argument cols is the columns in the drinks_smaller data frame you either want to or don’t want to “tidy.” Observe how we set this to -country indicating that we don’t want to “tidy” the country variable in drinks_smaller and rather only beer, spirit, and wine. Since country is a column that appears in drinks_smaller we don’t put quotation marks around it.\n\nThe third argument here of cols is a little nuanced, so let’s consider code that’s written slightly differently but that produces the same output:\n\n#|eval: false\ndrinks_smaller %&gt;% \n  pivot_longer(names_to = \"type\", \n               values_to = \"servings\", \n               cols = c(beer, spirit, wine))\n\n# A tibble: 12 × 3\n   country      type   servings\n   &lt;chr&gt;        &lt;chr&gt;     &lt;int&gt;\n 1 China        beer         79\n 2 China        spirit      192\n 3 China        wine          8\n 4 Italy        beer         85\n 5 Italy        spirit       42\n 6 Italy        wine        237\n 7 Saudi Arabia beer          0\n 8 Saudi Arabia spirit        5\n 9 Saudi Arabia wine          0\n10 USA          beer        249\n11 USA          spirit      158\n12 USA          wine         84\n\n\nNote that the third argument now specifies which columns we want to “tidy” with c(beer, spirit, wine), instead of the columns we don’t want to “tidy” using -country. We use the c() function to create a vector of the columns in drinks_smaller that we’d like to “tidy.” Note that since these three columns appear one after another in the drinks_smaller data frame, we could also do the following for the cols argument:\n\ndrinks_smaller %&gt;% \n  pivot_longer(names_to = \"type\", \n               values_to = \"servings\", \n               cols = beer:wine)\n\n# A tibble: 12 × 3\n   country      type   servings\n   &lt;chr&gt;        &lt;chr&gt;     &lt;int&gt;\n 1 China        beer         79\n 2 China        spirit      192\n 3 China        wine          8\n 4 Italy        beer         85\n 5 Italy        spirit       42\n 6 Italy        wine        237\n 7 Saudi Arabia beer          0\n 8 Saudi Arabia spirit        5\n 9 Saudi Arabia wine          0\n10 USA          beer        249\n11 USA          spirit      158\n12 USA          wine         84\n\ndrinks_smaller_tidy &lt;- drinks_smaller %&gt;%\n  gather(type, servings, -country)\n\nLet’s see what our “tidy” formatted data frame, drinks_smaller_tidy, looks like.\n\n\n# A tibble: 12 × 3\n   country      type   servings\n   &lt;chr&gt;        &lt;chr&gt;     &lt;int&gt;\n 1 China        beer         79\n 2 Italy        beer         85\n 3 Saudi Arabia beer          0\n 4 USA          beer        249\n 5 China        spirit      192\n 6 Italy        spirit       42\n 7 Saudi Arabia spirit        5\n 8 USA          spirit      158\n 9 China        wine          8\n10 Italy        wine        237\n11 Saudi Arabia wine          0\n12 USA          wine         84\n\n\nConverting “wide” format data to “tidy” format often confuses new R users. The only way to learn to get comfortable with the pivot_longer() function is with practice, practice, and more practice using different datasets. For example, run ?pivot_longer and look at the examples in the bottom of the help file.\nIf however you want to convert a “tidy” data frame to “wide” format, you will need to use the pivot_wider() function instead. Run ?pivot_wider and look at the examples in the bottom of the help file for examples.\nYou can also view examples of both pivot_longer() and pivot_wider() on the tidyverse.org webpage. There’s a nice example to check out the different functions available for data tidying and a case study using data from the World Health Organization on that webpage. Furthermore, each week the R4DS Online Learning Community posts a dataset in the weekly #TidyTuesday event that might serve as a nice place for you to find other data to explore and transform."
  },
  {
    "objectID": "dplyr.html#what-is-dplyr",
    "href": "dplyr.html#what-is-dplyr",
    "title": "6  Manipulating Data",
    "section": "6.1 What is dplyr",
    "text": "6.1 What is dplyr"
  },
  {
    "objectID": "ggplot2.html#how-to-plot",
    "href": "ggplot2.html#how-to-plot",
    "title": "7  Plotting Data",
    "section": "7.1 How to plot",
    "text": "7.1 How to plot"
  },
  {
    "objectID": "single.html",
    "href": "single.html",
    "title": "8  Simple",
    "section": "",
    "text": "What is regression"
  },
  {
    "objectID": "multiple.html",
    "href": "multiple.html",
    "title": "9  Multiple",
    "section": "",
    "text": "What is multiple regression"
  },
  {
    "objectID": "anova.html",
    "href": "anova.html",
    "title": "10  ANOVA",
    "section": "",
    "text": "What is ANOVA\nWhat is ANCOVA"
  },
  {
    "objectID": "simulation.html#simulate",
    "href": "simulation.html#simulate",
    "title": "11  Simulating Data",
    "section": "11.1 Simulate?",
    "text": "11.1 Simulate?"
  },
  {
    "objectID": "missingness.html#what-happened-to-my-data",
    "href": "missingness.html#what-happened-to-my-data",
    "title": "12  Missing Data",
    "section": "12.1 What happened to my data?",
    "text": "12.1 What happened to my data?"
  }
]